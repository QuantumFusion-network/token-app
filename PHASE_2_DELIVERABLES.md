# Phase 2 Deliverables - Workflow Asset Implementation

> **Status**: Awaiting Phase 1 approval  
> **Estimated Effort**: 2-3 days  
> **Output**: Production-ready workflow assets

---

## Overview

Upon approval of Phase 1 architecture, Phase 2 will create all workflow assets needed for the Claude Composer integration.

**Goal**: Enable end users to run: `npx degit user/polkadot-template my-app && cd my-app && [open Composer] → "Generate my app" → Working dApp in 5 minutes`

---

## Deliverable 1: Skills (8 Files)

### Format: Anthropic Skills Protocol

Each skill follows the structure:

```markdown
---
name: polkadot-api-transactions
description: Pattern guide for building transactions with polkadot-api
version: 1.0.0
tags: [polkadot, blockchain, transactions, papi]
---

# polkadot-api Transaction Patterns

## Overview
[Brief description of what this skill covers]

## Critical Rules
⚠️ [Most important do's and don'ts]

## Pattern 1: [Pattern Name]
### ✅ Correct Example
[Code example]

### ❌ Common Mistakes
[Anti-patterns]

### Why This Matters
[Explanation]

[... more patterns ...]

## Checklist
- [ ] Import from `polkadot-api` (not `@polkadot/api`)
- [ ] [... more checkboxes]
```

### Skills to Create

| # | Skill Name | Purpose | Source Patterns | Est. Lines |
|---|------------|---------|-----------------|------------|
| 1 | `polkadot-api-transactions.md` | Building transactions, using Binary, MultiAddress, TypedApi | Patterns 1-4, 12 | ~400 lines |
| 2 | `polkadot-api-queries.md` | Query patterns with TanStack Query, storage access | Pattern 9 | ~300 lines |
| 3 | `polkadot-api-observables.md` | Transaction observables, signSubmitAndWatch, lifecycle | Patterns 7, 14 | ~350 lines |
| 4 | `asset-pallet-patterns.md` | Assets pallet specifics (create, mint, transfer, destroy) | Current assetOperations.ts | ~400 lines |
| 5 | `batch-operations.md` | Using Utility.batch_all, atomic operations | Pattern 8 | ~250 lines |
| 6 | `balance-utilities.md` | toPlanck, fromPlanck, formatBalance usage | Pattern 6, 11 | ~300 lines |
| 7 | `component-patterns.md` | React form patterns, useAssetMutation, error handling | Pattern 15, CreateAsset.tsx | ~450 lines |
| 8 | `error-handling.md` | Dispatch errors, InvalidTxError, user messages | Pattern 10, errorParsing.ts | ~350 lines |

**Total: ~2,800 lines across 8 skills**

### Deliverable Format

```
.cursor/
└── composer/
    └── skills/
        ├── polkadot-api-transactions.md
        ├── polkadot-api-queries.md
        ├── polkadot-api-observables.md
        ├── asset-pallet-patterns.md
        ├── batch-operations.md
        ├── balance-utilities.md
        ├── component-patterns.md
        └── error-handling.md
```

**Validation**: Each skill will be reviewed against:
- ✅ Follows Anthropic Skills schema
- ✅ Includes critical warnings (e.g., don't use `@polkadot/api`)
- ✅ Has 3-5 complete code examples
- ✅ Has "Common Mistakes" section
- ✅ Has checklist for validation

---

## Deliverable 2: Reference Documents (4 Files)

### Format: Annotated Code + Architecture Explanations

Each reference doc includes:
- Complete, working code
- Inline comments explaining decisions
- Architectural context (how it fits in the system)
- Variations (e.g., 3 layout options)

### Documents to Create

| # | Document Name | Content | Source | Est. Lines |
|---|---------------|---------|--------|------------|
| 1 | `reference-CreateAsset.md` | Full CreateAsset component with annotations | CreateAsset.tsx + commentary | ~400 lines |
| 2 | `reference-assetOperations.md` | All asset operations with explanations | assetOperations.ts + commentary | ~300 lines |
| 3 | `reference-App-layouts.md` | 3 App.tsx variants (sidebar, topnav, minimal) | App.tsx variations | ~600 lines |
| 4 | `reference-transaction-lifecycle.md` | Transaction flow diagram + code walkthrough | TransactionContext + useTransaction | ~400 lines |

**Total: ~1,700 lines across 4 reference docs**

### Deliverable Format

```
docs/
├── reference-implementations/
│   ├── reference-CreateAsset.md
│   ├── reference-assetOperations.md
│   └── reference-App-layouts.md
└── architecture/
    └── reference-transaction-lifecycle.md
```

### Example: `reference-CreateAsset.md` Structure

```markdown
# Reference Implementation: CreateAsset Component

## Overview
Complete implementation of asset creation form with:
- Form state management (useState, not useReducer per CLAUDE.md)
- useAssetMutation for transaction handling
- Fee calculation with useFee
- Transaction review with TransactionReview
- Error handling with FeatureErrorBoundary

## Architecture Context
This component is **feature-specific** (generated by workflow).
It **reuses infrastructure**:
- useAssetMutation (template)
- TransactionReview (template)
- TransactionFormFooter (template)
- Balance utilities (template)

## Full Implementation

```typescript
import { useEffect, useState, type FormEvent } from 'react'
// [... full component code with inline comments ...]
```

## Key Patterns

### Pattern 1: Form State Management
[Explanation of why useState, not useReducer]

### Pattern 2: useAssetMutation Usage
[Explanation of parameters, validation, onSuccess]

[... more patterns ...]

## Adaptation Guide

To create a similar component for another operation:
1. Change operation function (createAssetBatch → mintTokens)
2. Update form fields (name, symbol → amount, recipient)
3. Update validation (isValid function)
4. Update toast config (createAssetToasts → mintTokensToasts)

## Checklist
- [ ] Uses useState for form state
- [ ] Wraps in FeatureErrorBoundary
- [ ] Uses useAssetMutation
- [ ] Includes TransactionReview
- [ ] [... more checkboxes]
```

---

## Deliverable 3: Validation Scripts (4 Files)

### Format: Executable TypeScript/Bash Scripts

Each script checks one aspect of code quality and outputs actionable errors.

### Scripts to Create

| # | Script Name | Purpose | Exit Code |
|---|-------------|---------|-----------|
| 1 | `validate-imports.ts` | Check for `@polkadot/api` (forbidden), ensure `polkadot-api` | 0 = pass, 1 = fail |
| 2 | `validate-types.ts` | Check for `any`, type assertions (`as`), unsafe code | 0 = pass, 1 = fail |
| 3 | `validate-exports.ts` | Ensure barrel files (`index.ts`) are updated | 0 = pass, 1 = fail |
| 4 | `test-connection.ts` | Verify network config, test connection | 0 = pass, 1 = fail |

**Total: ~400 lines across 4 scripts**

### Deliverable Format

```
scripts/
├── validate-imports.ts
├── validate-types.ts
├── validate-exports.ts
└── test-connection.ts
```

### Example: `validate-imports.ts`

```typescript
#!/usr/bin/env tsx

import { readFileSync } from 'fs'
import { glob } from 'glob'

interface ValidationError {
  file: string
  line: number
  message: string
}

const errors: ValidationError[] = []

// Find all TypeScript files
const files = await glob('src/**/*.{ts,tsx}', { ignore: ['**/*.test.ts', '**/*.test.tsx'] })

for (const file of files) {
  const content = readFileSync(file, 'utf-8')
  const lines = content.split('\n')
  
  lines.forEach((line, index) => {
    // Check for forbidden @polkadot/api imports
    if (line.includes("from '@polkadot/api'") || line.includes('from "@polkadot/api"')) {
      errors.push({
        file,
        line: index + 1,
        message: 'Forbidden import: Use "polkadot-api" instead of "@polkadot/api"'
      })
    }
    
    // Check for forbidden @polkadot/rpc-provider
    if (line.includes("@polkadot/rpc-provider")) {
      errors.push({
        file,
        line: index + 1,
        message: 'Forbidden import: Use "polkadot-api/ws-provider" instead'
      })
    }
  })
}

// Report errors
if (errors.length > 0) {
  console.error('\n❌ Import validation failed:\n')
  errors.forEach(({ file, line, message }) => {
    console.error(`  ${file}:${line}`)
    console.error(`    ${message}\n`)
  })
  process.exit(1)
} else {
  console.log('✅ All imports valid (using polkadot-api)')
  process.exit(0)
}
```

**Usage in workflow:**
```bash
pnpm tsx scripts/validate-imports.ts
```

Claude runs this automatically after code generation.

---

## Deliverable 4: Dynamic Prompt Generator

### Format: TypeScript Module + Configuration

A programmatic system that reads `wizard-config.json` and generates sequential prompts for Claude.

### Components

| # | Component | Purpose | Output |
|---|-----------|---------|--------|
| 1 | `WorkflowPromptGenerator.ts` | Main generator class | Array of prompts |
| 2 | `prompt-templates/` | Template fragments for each feature | Reusable strings |
| 3 | `workflow-config-schema.json` | JSON schema for validation | Schema file |
| 4 | `generate-prompts.ts` | CLI tool for testing | Executable script |

**Total: ~600 lines**

### Deliverable Format

```
workflow/
├── WorkflowPromptGenerator.ts    # Main class
├── prompt-templates/
│   ├── asset-operations.txt
│   ├── asset-components.txt
│   ├── nft-operations.txt        # Future
│   └── app-integration.txt
├── workflow-config-schema.json   # JSON schema
└── generate-prompts.ts           # CLI tool
```

### Example: `WorkflowPromptGenerator.ts`

```typescript
import type { WizardConfig, Task } from './types'
import * as templates from './prompt-templates'

export class WorkflowPromptGenerator {
  constructor(
    private config: WizardConfig,
    private skillsPath: string = '.cursor/composer/skills',
    private docsPath: string = 'docs'
  ) {}
  
  generate(): Task[] {
    const tasks: Task[] = []
    
    // Task 0: Validate environment
    tasks.push(this.createValidationTask())
    
    // Tasks for enabled features
    if (this.config.features.assets.enabled) {
      tasks.push(...this.generateAssetTasks())
    }
    
    if (this.config.features.nfts?.enabled) {
      tasks.push(...this.generateNftTasks())
    }
    
    // Task N: Integrate into App.tsx
    tasks.push(this.createAppIntegrationTask())
    
    // Task N+1: Final validation
    tasks.push(this.createFinalValidationTask())
    
    return tasks.sort((a, b) => a.order - b.order)
  }
  
  private generateAssetTasks(): Task[] {
    const operations = this.config.features.assets.operations
    
    return [
      {
        order: 10,
        type: 'library',
        prompt: templates.assetOperations({
          operations,
          network: this.config.deployment.network,
          skills: [
            'polkadot-api-transactions',
            'asset-pallet-patterns',
            'batch-operations'
          ]
        })
      },
      {
        order: 20,
        type: 'hooks',
        prompt: templates.assetHooks({
          skills: ['polkadot-api-queries']
        })
      },
      ...operations.map((op, idx) => ({
        order: 30 + idx,
        type: 'component' as const,
        prompt: templates.assetComponent({
          operation: op,
          skills: ['component-patterns', 'polkadot-api-transactions'],
          reference: 'reference-CreateAsset.md'
        })
      }))
    ]
  }
  
  // [... more methods ...]
}
```

### Example Usage

```typescript
import { WorkflowPromptGenerator } from './workflow/WorkflowPromptGenerator'
import wizardConfig from './wizard-config.json'

const generator = new WorkflowPromptGenerator(wizardConfig)
const tasks = generator.generate()

console.log(`Generated ${tasks.length} tasks:`)
tasks.forEach(task => {
  console.log(`\n[Task ${task.order}] ${task.type}`)
  console.log(task.prompt)
})
```

**Integration with Cursor**:  
The generated prompts can be:
1. Sent to Claude via Composer API (if available)
2. Displayed for user to copy-paste
3. Saved to `.cursor/prompts.txt` for manual execution

---

## Deliverable 5: Updated CLAUDE.md

### Format: Additional Sections in Existing CLAUDE.md

Add 3 new sections to the existing CLAUDE.md file.

### New Sections

#### Section 1: How This Template Works (for end users)

```markdown
## USING THIS TEMPLATE

**This template includes pre-built infrastructure:**
- ✅ Wallet connection (WalletContext + useWallet)
- ✅ Chain connection (ConnectionContext + useConnectionStatus)
- ✅ Transaction management (TransactionContext + useTransaction)
- ✅ Error handling (errorParsing, transactionErrors, error boundaries)
- ✅ Balance utilities (toPlanck, fromPlanck, formatBalance)
- ✅ UI components (shadcn/ui + generic components)

**To add features:**
1. Run the wizard → generates `wizard-config.json`
2. Open Cursor Composer
3. Type: "Generate my app based on wizard-config.json"
4. Claude will generate feature-specific code (operations, components, hooks)
5. Run: `pnpm install && pnpm papi && pnpm dev`

**Never regenerate infrastructure files.** They're tested and follow patterns.
```

#### Section 2: Adding New Features (iterative workflow)

```markdown
## ADDING FEATURES ITERATIVELY

**After initial generation, you can add more features:**

### Example 1: Add NFT Support
```bash
# Update wizard-config.json
{
  "features": {
    "assets": { "enabled": true, /* ... */ },
    "nfts": { "enabled": true }  // ← Add this
  }
}
```

In Composer:
```
"Add NFT minting capability based on wizard-config.json"
```

Claude will:
1. Load NFT skills (`nft-pallet-patterns.md`)
2. Generate `lib/nftOperations.ts`
3. Generate `components/NftMint.tsx`, etc.
4. Update `App.tsx` navigation
5. Run validation

### Example 2: Add Custom Operation
If you need a custom operation not in wizard config:

In Composer:
```
"Add freeze/thaw operations for assets.
Follow patterns from assetOperations.ts.
Use skills: polkadot-api-transactions, asset-pallet-patterns"
```

Claude will generate new functions in `assetOperations.ts` and corresponding components.
```

#### Section 3: Workflow Integration (how skills are used)

```markdown
## WORKFLOW SKILLS

**This template includes polkadot-api skills in `.cursor/composer/skills/`:**
- `polkadot-api-transactions.md` - Transaction building patterns
- `polkadot-api-queries.md` - Query patterns with TanStack
- `polkadot-api-observables.md` - Observable patterns
- `asset-pallet-patterns.md` - Assets pallet specifics
- `batch-operations.md` - Batch operations
- `balance-utilities.md` - Balance conversion/formatting
- `component-patterns.md` - React component patterns
- `error-handling.md` - Error parsing and messages

**When Claude generates code, it automatically:**
1. Loads relevant skills based on your request
2. Follows patterns from skills
3. Validates against CLAUDE.md conventions
4. Runs validation scripts

**You don't need to manually reference skills.** Just describe what you want to build.
```

**Total addition: ~150 lines to existing CLAUDE.md**

---

## Deliverable 6: JSON Schema for Wizard Config

### Format: JSON Schema + Examples

A formal schema that the wizard can use to validate user selections.

### Components

| # | Component | Purpose |
|---|-----------|---------|
| 1 | `wizard-config-schema.json` | JSON Schema v7 definition |
| 2 | `wizard-config.example.json` | Example: Minimal config |
| 3 | `wizard-config.full.example.json` | Example: All features |

**Total: ~300 lines**

### Deliverable Format

```
schema/
├── wizard-config-schema.json
├── examples/
│   ├── wizard-config.minimal.json
│   ├── wizard-config.assets-only.json
│   └── wizard-config.full.json
└── README.md  # Schema documentation
```

### Example: `wizard-config-schema.json`

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "title": "Polkadot dApp Wizard Configuration",
  "description": "Configuration for generating Polkadot dApps from template",
  "type": "object",
  "required": ["schema_version", "project", "deployment", "features", "ui"],
  "properties": {
    "schema_version": {
      "type": "string",
      "pattern": "^\\d+\\.\\d+\\.\\d+$",
      "description": "Semantic version of this schema"
    },
    "project": {
      "type": "object",
      "required": ["name"],
      "properties": {
        "name": {
          "type": "string",
          "minLength": 1,
          "maxLength": 100,
          "pattern": "^[a-z0-9-]+$",
          "description": "Project name (kebab-case)"
        },
        "description": {
          "type": "string",
          "maxLength": 500,
          "description": "Optional project description"
        }
      }
    },
    "deployment": {
      "type": "object",
      "required": ["environment", "network"],
      "properties": {
        "environment": {
          "type": "string",
          "enum": ["testnet", "mainnet", "local"],
          "description": "Target deployment environment"
        },
        "network": {
          "type": "object",
          "required": ["name", "wsUrl", "decimals", "symbol"],
          "properties": {
            "name": { "type": "string" },
            "wsUrl": { "type": "string", "format": "uri" },
            "decimals": { "type": "integer", "minimum": 0, "maximum": 18 },
            "symbol": { "type": "string", "maxLength": 10 }
          }
        }
      }
    },
    "features": {
      "type": "object",
      "properties": {
        "assets": {
          "type": "object",
          "required": ["enabled"],
          "properties": {
            "enabled": { "type": "boolean" },
            "operations": {
              "type": "array",
              "items": {
                "type": "string",
                "enum": ["create", "mint", "transfer", "destroy"]
              },
              "minItems": 1,
              "uniqueItems": true
            },
            "ui_style": {
              "type": "string",
              "enum": ["dashboard", "minimal", "embedded"],
              "default": "dashboard"
            }
          }
        }
        // [... more features ...]
      }
    },
    "ui": {
      "type": "object",
      "required": ["layout"],
      "properties": {
        "theme": {
          "type": "string",
          "enum": ["dark", "light", "system"],
          "default": "dark"
        },
        "layout": {
          "type": "string",
          "enum": ["sidebar", "topnav", "minimal"],
          "default": "sidebar"
        }
      }
    }
  }
}
```

---

## Phase 2 Timeline

### Week 1: Skills + Reference Docs
- **Day 1-2**: Create 8 skills (400-500 lines each)
- **Day 3**: Create 4 reference docs (300-600 lines each)
- **Day 4**: Review, testing, refinement

### Week 2: Scripts + Generator + Integration
- **Day 5**: Create 4 validation scripts
- **Day 6**: Create WorkflowPromptGenerator + templates
- **Day 7**: Update CLAUDE.md, create JSON schema
- **Day 8**: Integration testing, documentation

**Total: 8 days (~2 weeks with review cycles)**

---

## Validation Criteria

Each deliverable must pass:

### Skills
- [ ] Follows Anthropic Skills schema exactly
- [ ] Includes critical warnings section
- [ ] Has 3+ complete code examples
- [ ] Has "Common Mistakes" section
- [ ] Has validation checklist
- [ ] References current token app code
- [ ] All code examples run without errors

### Reference Docs
- [ ] Includes complete, working code
- [ ] Has architectural context
- [ ] Explains key decisions
- [ ] Includes adaptation guide
- [ ] Code matches CLAUDE.md conventions
- [ ] Validated by TypeScript compiler

### Validation Scripts
- [ ] Exits with code 0 (pass) or 1 (fail)
- [ ] Provides actionable error messages
- [ ] Includes file name + line number
- [ ] Can be run via `pnpm tsx scripts/*.ts`
- [ ] Tested on valid and invalid code

### Prompt Generator
- [ ] Validates wizard-config.json against schema
- [ ] Generates correct prompts for all features
- [ ] Includes skill references
- [ ] Orders tasks logically (deps first)
- [ ] Unit tests for all feature combinations

### CLAUDE.md Updates
- [ ] Consistent with existing style
- [ ] Adds value without redundancy
- [ ] References new workflow assets
- [ ] Includes concrete examples
- [ ] Reviewed for accuracy

### JSON Schema
- [ ] Valid JSON Schema v7
- [ ] All fields documented
- [ ] Examples validate against schema
- [ ] Covers future extensibility
- [ ] Includes migration guide

---

## Phase 2 Success Metrics

At the end of Phase 2, we should be able to:

1. ✅ **Clone template** → `npx degit user/polkadot-template my-app`
2. ✅ **Generate wizard config** → Use wizard UI or edit JSON manually
3. ✅ **Run generator** → `pnpm tsx workflow/generate-prompts.ts > prompts.txt`
4. ✅ **Execute in Composer** → Copy prompts to Claude or use API
5. ✅ **Validate output** → All validation scripts pass
6. ✅ **Build & run** → `pnpm install && pnpm papi && pnpm dev`
7. ✅ **Working dApp** → Asset management UI functional

**End-to-end test**: Junior developer with zero Polkadot knowledge can generate a working dApp in 10 minutes.

---

## Post-Phase 2: Phase 3 (Sample Implementation)

After Phase 2 assets are approved, Phase 3 will create:

1. **Sample: Asset Creation Skill** - One complete skill with full examples
2. **Sample: Dynamic Prompt** - Generated prompt for asset creation
3. **Sample: Validation Run** - End-to-end validation example
4. **Sample: Integration Test** - Full workflow test (wizard → generated code → working dApp)

This serves as a **proof of concept** before scaling to all features.

---

## Questions Before Starting Phase 2

1. **Skill versioning**: Should skills include version numbers for backward compatibility?
2. **Prompt format**: Single long prompt vs. sequential short prompts?
3. **Validation strictness**: Block on warnings or just errors?
4. **Skills distribution**: Include in template repo or separate package?
5. **Future features**: Should Phase 2 include NFT/governance skill stubs?
6. **Testing**: Unit tests for prompt generator, or manual testing only?

---

## Approval Checklist

Before proceeding to Phase 2 implementation:

- [ ] Phase 1 architecture approved
- [ ] Wizard JSON schema structure approved
- [ ] Template vs. generated boundary approved
- [ ] Skill topics and structure approved
- [ ] Validation script requirements approved
- [ ] Timeline and resource allocation approved
- [ ] Success metrics agreed upon

**Ready for Phase 2 implementation upon approval of this plan.**

